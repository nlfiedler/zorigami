* Zorigami
** Phase 4
*** TODO Develop the GraphQL schema to represent everything
**** DONE snapshots
**** TODO need a custom type for the =SystemTime= in =Snapshot=
***** consider using https://github.com/chronotope/chrono
***** juniper has built-in support for chrono types
**** DONE define a custom type for =Checksum= values called =Digest=
**** DONE =Digest= should check that input value is well-formed
**** DONE =BigInt= should handle parse errors properly
**** DONE define a custom type for file size
***** at best it will be 53-bit integers, because JavaScript on front-end
***** see the =BigInt= code in tanuki
***** 2^53 is a pretty big number: 9,007,199,254,740,992
***** 2^63 has a maximum value of: 9,223,372,036,854,775,807
**** DONE use =graphql_scalar!= macro to define serde functions for new types
**** DONE trees
**** DONE files
**** TODO store configuration: use json blobs?
**** DONE datasets
**** TODO datasets and stores
***** resolver will enforce write-once store assignment to a dataset
**** TODO just call =Database::new= every time, to ensure db is flushed
***** connection pooling sounds neat, but will it ever close the database?
*** TODO Bump up the number of concurrent threads in database test
*** TODO Test the GraphQL schema and resolvers
**** TODO digests that lack the proper algorithm prefix
**** TODO querying for things when there is nothing in the database
**** TODO querying snapshots
**** TODO querying trees
**** TODO querying files
**** TODO querying datasets
**** TODO mutating datasets
**** TODO querying stores
**** TODO mutating stores
**** TODO cannot change stores assigned to dataset once there are snapshots
*** TODO Read the db path from an environment variable
*** TODO Read the HTTP port from an environment variable
*** TODO Write a ReasonML frontend
**** TODO Add =bs-platform= dependency and =bsconfig.json= file
**** TODO Put front-end code in a directory named =web-src=
**** TODO Set up =gulp= and =webpack= to build the front-end code
**** TODO Set up apollo client dependency and schema tooling
**** TODO Set up the routing
**** TODO Write a simple home page that shows something
*** TODO Recover from unfinished backup procedure
**** When performing backup, check if latest snapshot exists and lacks an end time
**** If so, try to continue the backup with that snapshot
**** If not, make a new snapshot
**** If there are no changes at all (tree or file), delete the snapshot
*** TODO Manage stores, datasets, and configuration
*** TODO Exclude the database files from the data set(s)
*** TODO Add something that will run scheduled jobs
**** that is, an easy way to trigger backups according to the configuration
*** TODO Loose ends from Rust translation
**** TODO Learn how to manage application state
***** Actix offers state management for web code
***** https://github.com/SergioBenitez/state (MIT/Apache)
***** https://github.com/rust-redux/rust-redux (MIT)
***** https://github.com/jaredonline/redux-rs (???)
**** TODO Set up configuration for dev and testing
***** TODO replace hard-coded db_path in integration test
**** TODO Get basic database working
***** DONE read https://github.com/facebook/rocksdb/wiki/RocksDB-Basics
***** DONE write an "insert if missing" function
****** does not write if the key is already present
***** DONE decide how to store "documents" in the database
****** use [[https://github.com/serde-rs/serde][serde]] to efficiently de/serialize to many formats
****** can =skip= fields that do not need serde
****** can write custom serde functionality as needed
****** DONE how to manage versioning of the data structures?
******* can use =#[serde(default)]= and =Default= to fill in blanks
****** =serde_json= is maintained by serde community
****** [[https://github.com/pyfisch/cbor][pyfisch/cbor]]; CBOR is an internet standard (RFC 7049)
****** [[https://github.com/3Hren/msgpack-rust][3Hren/msgpack-rust]] is not actively developed
***** DONE Use serde ~rename~ feature to make short field names
***** DONE write functions for insert/get tree
***** DONE write functions for insert/get snapshot
***** TODO write functions for insert/get configuration
***** DONE write functions for insert/get xattr
***** DONE write functions for insert/get file
***** DONE write functions for insert/get chunk
***** DONE write functions for insert/get pack
***** DONE work out how to support the counts of each type of document
***** DONE decide how the chunk and pack records will be stored to facilitate multi-host dedupe
*** TODO If the new snapshot has no changes from previous, delete it
** Phase 5
*** TODO Get encryption password from an environment variable
*** TODO Use this to replace =replicaz= by persisting to USB drive
*** TODO Use this to replace =replicaz= by persisting over SFTP
*** TODO Enable configuring various overrides in a dataset
**** schedule/frequency overrides
**** file/dirctory ignore overrides
**** storage overrides (e.g. `local` vs `aws`)
*** TODO Support multiple roots per dataset
*** TODO Verify checksum of downloaded packs during restore
*** TODO Store database in a bucket named after the "computer UUID"
*** TODO Store pack files in Google Cloud Storage
**** Check for bucket name collisions and retry in pack store
**** https://cloud.google.com/storage/docs/best-practices
*** TODO Use this to replace =akashita= for online backups
** Phase 6
*** TODO Try building on Windows
*** TODO Use this to replace Time Machine (store on server using SFTP)
**** Need to handle computer shutdown during a backup
**** Use =launchd= to manage the process, have it start automatically
*** TODO Restore file attributes from tree entry
**** TODO File mode
**** TODO File user/group
**** TODO File extended attributes
*** TODO Restore directories from snapshot
**** TODO Directory mode
**** TODO Directory user/group
**** TODO Directory extended attributes
**** TODO Restore multiple files efficiently
**** TODO Restore a directory tree efficiently
*** TODO Detect files changing between snapshot and pack building time
**** use the =changed= record property to track this
*** TODO Detect file deletion during backup, mark file record as skipped
*** TODO Detect and prune stale snapshots that never completely uploaded
**** Stale snapshots exist in the database but are not referenced elsewhere
*** TODO Support snapshots consisting only of mode/owner changes
**** i.e. no file content changes, just the database records
*** TODO Restore the backup database
**** TODO Restore to a different directory, then copy over records
*** TODO Support deduplication across multiple computers
**** Place the chunks and packs in a seperate "database" for syncing
***** For RocksDB, use a column family if it helps with =GetUpdatesSince()=
**** RocksDB replication story as of 2019-02-20:
: Q: Does RocksDB support replication?
: A: No, RocksDB does not directly support replication. However, it offers
: some APIs that can be used as building blocks to support replication.
: For instance, GetUpdatesSince() allows developers to iterate though all
: updates since a specific point in time.
***** see =GetUpdatesSince()= and =PutLogData()= functions
**** User configures the host name of the ~peer~ installation
***** Use that to form the URL with which to =sync=
**** Share the chunks and packs documents with a ~peer~ installation
**** At the start of backup, sync with the ~peer~ to get latest chunks/packs
*** TODO Automatically prune backups more then N days old
**** For Google and Amazon, anything older than 90 days is free to remove
**** This would be a configuration setting, with defaults and path-specific
*** TODO Option to keep N daily, M weekly, and P monthly backups (a la Attic backup)
*** TODO Command-line option to dump database to json (separate by key prefix, e.g. ~chunk~)
** Phase 7
*** TODO Consider how to deal with partial uploads (e.g. Minio/S3 has a means of handling these)
*** TODO Design garbage collection solution (see NOTES)
*** TODO Pack store should recommend pack sizes
**** e.g. Glacier recommends archives greater than 100mb
*** TODO Support Windows file types
**** ReadOnly
**** Hidden
**** System
*** TODO Support SFTP with private key authentication
**** TODO allow private key locked with passprhase
*** TODO Permit removing a store from a dataset
**** would encourage user to clean up the remote files
**** for local store, could remove the files immediately
**** must invalidate all of the snapshots effected by the missing store
*** TODO Permit moving from one store to another
**** would mean downloading the packs and uploading them to the new store
*** TODO Support Amazon S3, Minio
**** Need to limit number of remote buckets to 100
**** Bucket limit: catch the error and handle by re-using another bucket
*** TODO Support Amazon Glacier
**** Use S3 to store the database-to-archive mapping of each snapshot
**** Offer user option to use "expedited" retrievals so they go faster
*** TODO Support Microsoft Azure blob storage
*** TODO Support Backblaze B2
*** TODO Support [[https://wiki.openstack.org/wiki/Swift][OpenStack Swift]]
*** TODO Support Wasabi
*** TODO Support Google Drive
*** TODO Support Dropbox
*** TODO Support Oracle Cloud Storage
*** TODO Support IBM Cloud Storage
*** TODO Support Rackspace Cloud Files
*** TODO Consider how to backup and restore FIFO, BLK, and CHR "files"
**** c.f. https://github.com/jborg/attic/blob/master/attic/archive.py
**** c.f. https://github.com/avz/node-mkfifo (for FIFO)
**** c.f. https://github.com/mafintosh/mknod (for BLK and CHR)
* Desktop App
** TODO Read https://youngdynasty.net/posts/writing-mac-apps-in-go/
** Phase N: Revery?
*** https://github.com/revery-ui/revery
*** ReasonML
*** React-like UI
*** Redux-like state management
*** Compiles to native
*** Would not be using CSS, presumably
*** Does it have support for systray?
*** Does it have support for dock icons?
** Phase N: Electron
*** TODO Write it in TypeScript
**** However, TypeScript and redux might get ugly fast
*** TODO Consider using [[https://github.com/neon-bindings/neon][Neon bindings]] to write some parts in Rust
*** TODO Create a system tray icon/widget
**** Popup menu like Time Machine
**** Show current status, last backup
**** Action to open the app and examine snapshots
**** Action to open the app and check settings
* Product
** Name
*** Joseph suggests "Attic"
**** =atticapp.com= is taken
**** =attic.app= is for sale
**** Look for ~attic~ in different languages
**** Esperanto: ~mansardo~
***** also means something in Macedonian
**** Hawaiian: ~kaukau~
**** Latin: ~atticae~
* Technical Information
** Exploring other languages
*** Compile to native for easy deployment
*** Compile to native for code obfuscation
*** Rust
**** Advantages
***** compile to native
***** expressive, safe type system
***** good dependency management
***** lots of useful tools (e.g. clippy)
**** Disadvantages
***** fewer libraries compared to Go
**** DONE GraphQL server
***** Make sure it can generate a schema.json
***** Should be able to parse schema definition (for docs)
***** https://github.com/graphql-rust/juniper (BSD)
****** supports entire GraphQL specification
****** does /not/ read GraphQL schema language
****** supports GraphiQL and Playground
****** is not the HTTP server, but integrates with them
****** uses macros for schema documentation
***** tutorial at [[http://alex.amiran.it/post/2018-08-16-rust-graphql-webserver-with-warp-juniper-and-mongodb.html][alex.amiran.it]] that uses warp web framework
***** old https://github.com/nrc/graphql (MIT/Apache)
**** DONE Web framework
***** our needs are simple, so a simple framework is best
***** Actix https://actix.rs (Apache 2.0)
****** works with stable Rust
****** powerful and easy to use
****** testing library
****** integrates with juniper
****** offers state management for web code
****** lot more actively used than warp
***** warp https://github.com/seanmonstar/warp (MIT)
****** works with stable Rust
****** powerful and easy to use
****** testing library
****** integrates with juniper
***** Rocket https://rocket.rs (Apache 2.0)
****** requires Rust nightly because of fancy macros
****** routing using macros
****** streams input and output
****** cookies
****** json
****** environment configuration
****** testing library
****** integrates with juniper
***** Gotham https://gotham.rs (MIT/Apache 2.0)
****** targets stable Rust
****** routing
****** middleware
****** sessions
****** cookies
****** templates
****** testing library
****** how to integrate with juniper is unknown
***** Iron http://ironframework.io (MIT)
****** crate has not been updated since 2017
****** everything is middleware that must be added in
****** integrates with juniper
***** Nickel http://nickel-org.github.io (Express.js like) (MIT)
****** pretty basic compared to Rocket
***** pretty basic https://github.com/carllerche/tower-web (MIT)
****** competing with warp? hyper?
**** DONE Database
***** ideally want something well maintained, reliable
***** schema is pretty simple, could use key/value store
***** RocksDB https://github.com/rust-rocksdb/rust-rocksdb (Apache)
****** statically links everything, including compression support
***** SQLite https://github.com/jgallagher/rusqlite (MIT)
***** Rust wrapper to LevelDB https://github.com/skade/leveldb
***** LevelDB in Rust (active?) https://bitbucket.org/dermesser/leveldb-rs/overview
**** DONE dotenv
***** the canonical crate repo has been emptied, there are many forks of the old code
***** most-up-to-date https://github.com/apiraino/rust-dotenv (MIT)
**** DONE Configuration
***** https://github.com/mehcode/config-rs (MIT/Apache)
**** DONE =getpwuid= and =getgrgid= support
***** libc: https://crates.io/crates/libc (MIT/Apache 2.0)
**** DONE test library
***** https://github.com/rust-rspec/rspec (MPL-2.0)
****** appears to be dead
***** https://github.com/utkarshkukreti/speculate.rs (MIT)
****** works well for integration tests
**** DONE UUID support
***** https://github.com/uuid-rs/uuid (MIT/Apache 2.0)
**** DONE xattr support
***** Unix only: https://github.com/Stebalien/xattr (MIT/Apache 2.0)
**** DONE CDC
***** https://github.com/jrobhoward/quickcdc (MIT/Apache 2.0)
****** not quite FastCDC, given dates of paper, but should be close enough
****** use a constant salt value for predictable results
****** example uses =memmap= crate to read large files
**** DONE Tar file
***** https://github.com/alexcrichton/tar-rs (MIT/Apache 2.0)
**** DONE PGP/Encryption
***** https://github.com/gpg-rs/gpgme (LGPL)
****** will need to bundle the =gpgme= library (unless statically linked)
***** cryptostream https://github.com/neosmart/cryptostream (MIT)
***** basic packets [[https://github.com/csssuf/pretty-good][csssuf/pretty-good]]
***** read only [[https://nest.pijul.com/pmeunier/openpgp][pijul]] openpgp
**** DONE ULID
***** https://github.com/dylanhart/ulid-rs (MIT)
**** DONE SFTP client
***** https://github.com/alexcrichton/ssh2-rs (MIT/Apache 2.0)
**** DONE AWS client
***** Rusoto https://www.rusoto.org (MIT)
**** DONE Google Cloud client
***** https://github.com/Byron/google-apis-rs (MIT/Apache 2.0)
**** DONE Minio client
***** Rusoto supports Minio https://github.com/rusoto/rusoto (MIT)
*** Go vs Rust
**** Go: first class support for cloud services
**** Go: statically linked OpenPGP readily available
**** Go: easy to read and write language
**** Rust: mature dependency management tooling
**** Rust: cargo has good editor support
**** Rust: expressive type system
**** Rust: nominal subtyping is much easier to follow
**** Rust: streamlined error handling
**** Rust: fine-grained namespaces and visibility control
