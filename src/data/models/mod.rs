//
// Copyright (c) 2020 Nathan Fiedler
//
use crate::domain::entities::{Checksum, Chunk, Store, StoreType};
use serde::{Deserialize, Deserializer, Serialize, Serializer};
use std::collections::HashMap;
use std::path::PathBuf;

// Derive for a remote type has trouble when nested in an Option, as in the
// packfile field of the Chunk struct.
impl Serialize for Checksum {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match *self {
            Checksum::SHA1(ref s) => serializer.serialize_newtype_variant("Checksum", 0, "SHA1", s),
            Checksum::SHA256(ref s) => {
                serializer.serialize_newtype_variant("Checksum", 1, "SHA256", s)
            }
        }
    }
}

//
// Generated by using `cargo expand` on a simple example that defines the
// Checksum type and uses serde derive, which generates this code.
//
// 1. cargo new serdex
// 2. Add serde to Cargo.toml
// 3. Copy the Checksum definition to main.rs
// 4. Add #[derive(Serialize, Deserialize)] to the Checksum type
// 4. cargo expand
//
impl<'de> Deserialize<'de> for Checksum {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        enum __Field {
            __field0,
            __field1,
        }
        struct __FieldVisitor;
        impl<'de> serde::de::Visitor<'de> for __FieldVisitor {
            type Value = __Field;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "variant identifier")
            }
            fn visit_u64<__E>(self, __value: u64) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    0u64 => serde::export::Ok(__Field::__field0),
                    1u64 => serde::export::Ok(__Field::__field1),
                    _ => serde::export::Err(serde::de::Error::invalid_value(
                        serde::de::Unexpected::Unsigned(__value),
                        &"variant index 0 <= i < 2",
                    )),
                }
            }
            fn visit_str<__E>(self, __value: &str) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    "SHA1" => serde::export::Ok(__Field::__field0),
                    "SHA256" => serde::export::Ok(__Field::__field1),
                    _ => serde::export::Err(serde::de::Error::unknown_variant(__value, VARIANTS)),
                }
            }
            fn visit_bytes<__E>(self, __value: &[u8]) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    b"SHA1" => serde::export::Ok(__Field::__field0),
                    b"SHA256" => serde::export::Ok(__Field::__field1),
                    _ => {
                        let __value = &serde::export::from_utf8_lossy(__value);
                        serde::export::Err(serde::de::Error::unknown_variant(__value, VARIANTS))
                    }
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for __Field {
            #[inline]
            fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
            where
                __D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
            }
        }
        struct __Visitor<'de> {
            marker: serde::export::PhantomData<Checksum>,
            lifetime: serde::export::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = Checksum;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "enum Checksum")
            }
            fn visit_enum<__A>(self, __data: __A) -> serde::export::Result<Self::Value, __A::Error>
            where
                __A: serde::de::EnumAccess<'de>,
            {
                match match serde::de::EnumAccess::variant(__data) {
                    serde::export::Ok(__val) => __val,
                    serde::export::Err(__err) => {
                        return serde::export::Err(__err);
                    }
                } {
                    (__Field::__field0, __variant) => serde::export::Result::map(
                        serde::de::VariantAccess::newtype_variant::<String>(__variant),
                        Checksum::SHA1,
                    ),
                    (__Field::__field1, __variant) => serde::export::Result::map(
                        serde::de::VariantAccess::newtype_variant::<String>(__variant),
                        Checksum::SHA256,
                    ),
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["SHA1", "SHA256"];
        deserializer.deserialize_enum(
            "Checksum",
            VARIANTS,
            __Visitor {
                marker: serde::export::PhantomData::<Checksum>,
                lifetime: serde::export::PhantomData,
            },
        )
    }
}

#[derive(Serialize, Deserialize)]
#[serde(remote = "Chunk")]
pub struct ChunkDef {
    #[serde(skip)]
    pub digest: Checksum,
    // This is _not_ saved to the database since an identical chunk may appear
    // in different files at different offsets.
    #[serde(skip)]
    pub offset: usize,
    #[serde(rename = "le")]
    pub length: usize,
    #[serde(skip)]
    pub filepath: Option<PathBuf>,
    #[serde(rename = "pf")]
    pub packfile: Option<Checksum>,
}

#[derive(Serialize, Deserialize)]
#[serde(remote = "StoreType")]
pub enum StoreTypeDef {
    LOCAL,
    MINIO,
    SFTP,
}

#[derive(Serialize, Deserialize)]
#[serde(remote = "Store")]
pub struct StoreDef {
    #[serde(skip)]
    pub id: String,
    #[serde(rename = "st", with = "StoreTypeDef")]
    pub store_type: StoreType,
    #[serde(rename = "la")]
    pub label: String,
    #[serde(rename = "pp")]
    pub properties: HashMap<String, String>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use failure::Error;

    #[test]
    fn test_checksum_serde() -> Result<(), Error> {
        // arrange
        let digest = Checksum::SHA1(String::from("65ace06cc7f835c497811ea7199968a119eeba4b"));
        // act
        let mut buffer: Vec<u8> = Vec::new();
        let mut ser = serde_json::Serializer::new(&mut buffer);
        Checksum::serialize(&digest, &mut ser)?;
        let as_text = String::from_utf8(buffer)?;
        let mut de = serde_json::Deserializer::from_str(&as_text);
        let actual = Checksum::deserialize(&mut de)?;
        // assert
        assert_eq!(actual, digest);
        Ok(())
    }

    #[test]
    fn test_chunk_serde() -> Result<(), Error> {
        // arrange
        let digest = Checksum::SHA1(String::from("65ace06cc7f835c497811ea7199968a119eeba4b"));
        let mut chunk = Chunk::new(digest, 0, 1024);
        let packfile = Checksum::SHA1(String::from("835c497811ea71999665ace06cc7f8a119eeba4b"));
        chunk = chunk.packfile(packfile.clone());
        // act
        let mut buffer: Vec<u8> = Vec::new();
        let mut ser = serde_json::Serializer::new(&mut buffer);
        ChunkDef::serialize(&chunk, &mut ser)?;
        let as_text = String::from_utf8(buffer)?;
        let mut de = serde_json::Deserializer::from_str(&as_text);
        let actual = ChunkDef::deserialize(&mut de)?;
        // assert
        let null_digest = Checksum::SHA1(String::from("0000000000000000000000000000000000000000"));
        assert_eq!(actual.digest, null_digest);
        assert_eq!(actual.length, chunk.length);
        assert_eq!(actual.packfile, chunk.packfile);
        Ok(())
    }

    #[test]
    fn test_store_serde() -> Result<(), Error> {
        // arrange
        let mut properties: HashMap<String, String> = HashMap::new();
        properties.insert("basepath".to_owned(), "/home/planet".to_owned());
        let store = Store {
            id: "cafebabe".to_owned(),
            store_type: StoreType::LOCAL,
            label: "mylocalstore".to_owned(),
            properties,
        };
        // act
        let mut buffer: Vec<u8> = Vec::new();
        let mut ser = serde_json::Serializer::new(&mut buffer);
        StoreDef::serialize(&store, &mut ser)?;
        let as_text = String::from_utf8(buffer)?;
        let mut de = serde_json::Deserializer::from_str(&as_text);
        let actual = StoreDef::deserialize(&mut de)?;
        // assert
        // id is not serialized in the record itself
        assert_eq!(actual.id, "");
        assert_eq!(actual.store_type, store.store_type);
        assert_eq!(actual.label, store.label);
        assert_eq!(actual.properties, store.properties);
        Ok(())
    }
}
