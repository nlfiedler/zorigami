//
// Generated by using `cargo expand` on a simple example that defines the types
// to be serialized, with serde derive pragma.
//
// 1. cargo new serdex
// 2. Add serde to Cargo.toml
// 3. Copy the type definitions to main.rs
// 4. Add #[derive(Serialize, Deserialize)] to each type
// 5. cargo expand
// 6. Copy the results here, stripping away the compiler directives
//
use chrono::prelude::*;
use crate::domain::entities::{Checksum, EntryType, Tree, TreeEntry, TreeReference};
use std::collections::HashMap;

impl serde::Serialize for EntryType {
    fn serialize<__S>(&self, __serializer: __S) -> serde::export::Result<__S::Ok, __S::Error>
    where
        __S: serde::Serializer,
    {
        match *self {
            EntryType::FILE => {
                serde::Serializer::serialize_unit_variant(__serializer, "EntryType", 0u32, "FILE")
            }
            EntryType::DIR => {
                serde::Serializer::serialize_unit_variant(__serializer, "EntryType", 1u32, "DIR")
            }
            EntryType::LINK => {
                serde::Serializer::serialize_unit_variant(__serializer, "EntryType", 2u32, "LINK")
            }
            EntryType::ERROR => {
                serde::Serializer::serialize_unit_variant(__serializer, "EntryType", 3u32, "ERROR")
            }
        }
    }
}

impl<'de> serde::Deserialize<'de> for EntryType {
    fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
    where
        __D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        enum __Field {
            __field0,
            __field1,
            __field2,
            __field3,
        }
        struct __FieldVisitor;
        impl<'de> serde::de::Visitor<'de> for __FieldVisitor {
            type Value = __Field;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "variant identifier")
            }
            fn visit_u64<__E>(self, __value: u64) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    0u64 => serde::export::Ok(__Field::__field0),
                    1u64 => serde::export::Ok(__Field::__field1),
                    2u64 => serde::export::Ok(__Field::__field2),
                    3u64 => serde::export::Ok(__Field::__field3),
                    _ => serde::export::Err(serde::de::Error::invalid_value(
                        serde::de::Unexpected::Unsigned(__value),
                        &"variant index 0 <= i < 4",
                    )),
                }
            }
            fn visit_str<__E>(self, __value: &str) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    "FILE" => serde::export::Ok(__Field::__field0),
                    "DIR" => serde::export::Ok(__Field::__field1),
                    "LINK" => serde::export::Ok(__Field::__field2),
                    "ERROR" => serde::export::Ok(__Field::__field3),
                    _ => serde::export::Err(serde::de::Error::unknown_variant(__value, VARIANTS)),
                }
            }
            fn visit_bytes<__E>(self, __value: &[u8]) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    b"FILE" => serde::export::Ok(__Field::__field0),
                    b"DIR" => serde::export::Ok(__Field::__field1),
                    b"LINK" => serde::export::Ok(__Field::__field2),
                    b"ERROR" => serde::export::Ok(__Field::__field3),
                    _ => {
                        let __value = &serde::export::from_utf8_lossy(__value);
                        serde::export::Err(serde::de::Error::unknown_variant(__value, VARIANTS))
                    }
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for __Field {
            #[inline]
            fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
            where
                __D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
            }
        }
        struct __Visitor<'de> {
            marker: serde::export::PhantomData<EntryType>,
            lifetime: serde::export::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = EntryType;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "enum EntryType")
            }
            fn visit_enum<__A>(self, __data: __A) -> serde::export::Result<Self::Value, __A::Error>
            where
                __A: serde::de::EnumAccess<'de>,
            {
                match match serde::de::EnumAccess::variant(__data) {
                    serde::export::Ok(__val) => __val,
                    serde::export::Err(__err) => {
                        return serde::export::Err(__err);
                    }
                } {
                    (__Field::__field0, __variant) => {
                        match serde::de::VariantAccess::unit_variant(__variant) {
                            serde::export::Ok(__val) => __val,
                            serde::export::Err(__err) => {
                                return serde::export::Err(__err);
                            }
                        };
                        serde::export::Ok(EntryType::FILE)
                    }
                    (__Field::__field1, __variant) => {
                        match serde::de::VariantAccess::unit_variant(__variant) {
                            serde::export::Ok(__val) => __val,
                            serde::export::Err(__err) => {
                                return serde::export::Err(__err);
                            }
                        };
                        serde::export::Ok(EntryType::DIR)
                    }
                    (__Field::__field2, __variant) => {
                        match serde::de::VariantAccess::unit_variant(__variant) {
                            serde::export::Ok(__val) => __val,
                            serde::export::Err(__err) => {
                                return serde::export::Err(__err);
                            }
                        };
                        serde::export::Ok(EntryType::LINK)
                    }
                    (__Field::__field3, __variant) => {
                        match serde::de::VariantAccess::unit_variant(__variant) {
                            serde::export::Ok(__val) => __val,
                            serde::export::Err(__err) => {
                                return serde::export::Err(__err);
                            }
                        };
                        serde::export::Ok(EntryType::ERROR)
                    }
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["FILE", "DIR", "LINK", "ERROR"];
        serde::Deserializer::deserialize_enum(
            __deserializer,
            "EntryType",
            VARIANTS,
            __Visitor {
                marker: serde::export::PhantomData::<EntryType>,
                lifetime: serde::export::PhantomData,
            },
        )
    }
}

impl serde::Serialize for TreeReference {
    fn serialize<__S>(&self, __serializer: __S) -> serde::export::Result<__S::Ok, __S::Error>
    where
        __S: serde::Serializer,
    {
        match *self {
            TreeReference::LINK(ref __field0) => serde::Serializer::serialize_newtype_variant(
                __serializer,
                "TreeReference",
                0u32,
                "LINK",
                __field0,
            ),
            TreeReference::TREE(ref __field0) => serde::Serializer::serialize_newtype_variant(
                __serializer,
                "TreeReference",
                1u32,
                "TREE",
                __field0,
            ),
            TreeReference::FILE(ref __field0) => serde::Serializer::serialize_newtype_variant(
                __serializer,
                "TreeReference",
                2u32,
                "FILE",
                __field0,
            ),
        }
    }
}

impl<'de> serde::Deserialize<'de> for TreeReference {
    fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
    where
        __D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        enum __Field {
            __field0,
            __field1,
            __field2,
        }
        struct __FieldVisitor;
        impl<'de> serde::de::Visitor<'de> for __FieldVisitor {
            type Value = __Field;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "variant identifier")
            }
            fn visit_u64<__E>(self, __value: u64) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    0u64 => serde::export::Ok(__Field::__field0),
                    1u64 => serde::export::Ok(__Field::__field1),
                    2u64 => serde::export::Ok(__Field::__field2),
                    _ => serde::export::Err(serde::de::Error::invalid_value(
                        serde::de::Unexpected::Unsigned(__value),
                        &"variant index 0 <= i < 3",
                    )),
                }
            }
            fn visit_str<__E>(self, __value: &str) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    "LINK" => serde::export::Ok(__Field::__field0),
                    "TREE" => serde::export::Ok(__Field::__field1),
                    "FILE" => serde::export::Ok(__Field::__field2),
                    _ => serde::export::Err(serde::de::Error::unknown_variant(__value, VARIANTS)),
                }
            }
            fn visit_bytes<__E>(self, __value: &[u8]) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    b"LINK" => serde::export::Ok(__Field::__field0),
                    b"TREE" => serde::export::Ok(__Field::__field1),
                    b"FILE" => serde::export::Ok(__Field::__field2),
                    _ => {
                        let __value = &serde::export::from_utf8_lossy(__value);
                        serde::export::Err(serde::de::Error::unknown_variant(__value, VARIANTS))
                    }
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for __Field {
            #[inline]
            fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
            where
                __D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
            }
        }
        struct __Visitor<'de> {
            marker: serde::export::PhantomData<TreeReference>,
            lifetime: serde::export::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = TreeReference;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "enum TreeReference")
            }
            fn visit_enum<__A>(self, __data: __A) -> serde::export::Result<Self::Value, __A::Error>
            where
                __A: serde::de::EnumAccess<'de>,
            {
                match match serde::de::EnumAccess::variant(__data) {
                    serde::export::Ok(__val) => __val,
                    serde::export::Err(__err) => {
                        return serde::export::Err(__err);
                    }
                } {
                    (__Field::__field0, __variant) => serde::export::Result::map(
                        serde::de::VariantAccess::newtype_variant::<String>(__variant),
                        TreeReference::LINK,
                    ),
                    (__Field::__field1, __variant) => serde::export::Result::map(
                        serde::de::VariantAccess::newtype_variant::<Checksum>(__variant),
                        TreeReference::TREE,
                    ),
                    (__Field::__field2, __variant) => serde::export::Result::map(
                        serde::de::VariantAccess::newtype_variant::<Checksum>(__variant),
                        TreeReference::FILE,
                    ),
                }
            }
        }
        const VARIANTS: &'static [&'static str] = &["LINK", "TREE", "FILE"];
        serde::Deserializer::deserialize_enum(
            __deserializer,
            "TreeReference",
            VARIANTS,
            __Visitor {
                marker: serde::export::PhantomData::<TreeReference>,
                lifetime: serde::export::PhantomData,
            },
        )
    }
}

impl serde::Serialize for TreeEntry {
    fn serialize<__S>(&self, __serializer: __S) -> serde::export::Result<__S::Ok, __S::Error>
    where
        __S: serde::Serializer,
    {
        let mut _serde_state = match serde::Serializer::serialize_struct(
            __serializer,
            "TreeEntry",
            false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
        ) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "nm", &self.name) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "ty", &self.fstype) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "mo", &self.mode) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "ui", &self.uid) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "us", &self.user) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "gi", &self.gid) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "gr", &self.group) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "ct", &self.ctime) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "mt", &self.mtime) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "tr", &self.reference)
        {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "xa", &self.xattrs) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        serde::ser::SerializeStruct::end(_serde_state)
    }
}

impl<'de> serde::Deserialize<'de> for TreeEntry {
    fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
    where
        __D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        enum __Field {
            __field0,
            __field1,
            __field2,
            __field3,
            __field4,
            __field5,
            __field6,
            __field7,
            __field8,
            __field9,
            __field10,
            __ignore,
        }
        struct __FieldVisitor;
        impl<'de> serde::de::Visitor<'de> for __FieldVisitor {
            type Value = __Field;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "field identifier")
            }
            fn visit_u64<__E>(self, __value: u64) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    0u64 => serde::export::Ok(__Field::__field0),
                    1u64 => serde::export::Ok(__Field::__field1),
                    2u64 => serde::export::Ok(__Field::__field2),
                    3u64 => serde::export::Ok(__Field::__field3),
                    4u64 => serde::export::Ok(__Field::__field4),
                    5u64 => serde::export::Ok(__Field::__field5),
                    6u64 => serde::export::Ok(__Field::__field6),
                    7u64 => serde::export::Ok(__Field::__field7),
                    8u64 => serde::export::Ok(__Field::__field8),
                    9u64 => serde::export::Ok(__Field::__field9),
                    10u64 => serde::export::Ok(__Field::__field10),
                    _ => serde::export::Err(serde::de::Error::invalid_value(
                        serde::de::Unexpected::Unsigned(__value),
                        &"field index 0 <= i < 11",
                    )),
                }
            }
            fn visit_str<__E>(self, __value: &str) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    "nm" => serde::export::Ok(__Field::__field0),
                    "ty" => serde::export::Ok(__Field::__field1),
                    "mo" => serde::export::Ok(__Field::__field2),
                    "ui" => serde::export::Ok(__Field::__field3),
                    "us" => serde::export::Ok(__Field::__field4),
                    "gi" => serde::export::Ok(__Field::__field5),
                    "gr" => serde::export::Ok(__Field::__field6),
                    "ct" => serde::export::Ok(__Field::__field7),
                    "mt" => serde::export::Ok(__Field::__field8),
                    "tr" => serde::export::Ok(__Field::__field9),
                    "xa" => serde::export::Ok(__Field::__field10),
                    _ => serde::export::Ok(__Field::__ignore),
                }
            }
            fn visit_bytes<__E>(self, __value: &[u8]) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    b"nm" => serde::export::Ok(__Field::__field0),
                    b"ty" => serde::export::Ok(__Field::__field1),
                    b"mo" => serde::export::Ok(__Field::__field2),
                    b"ui" => serde::export::Ok(__Field::__field3),
                    b"us" => serde::export::Ok(__Field::__field4),
                    b"gi" => serde::export::Ok(__Field::__field5),
                    b"gr" => serde::export::Ok(__Field::__field6),
                    b"ct" => serde::export::Ok(__Field::__field7),
                    b"mt" => serde::export::Ok(__Field::__field8),
                    b"tr" => serde::export::Ok(__Field::__field9),
                    b"xa" => serde::export::Ok(__Field::__field10),
                    _ => serde::export::Ok(__Field::__ignore),
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for __Field {
            #[inline]
            fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
            where
                __D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
            }
        }
        struct __Visitor<'de> {
            marker: serde::export::PhantomData<TreeEntry>,
            lifetime: serde::export::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = TreeEntry;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "struct TreeEntry")
            }
            #[inline]
            fn visit_seq<__A>(
                self,
                mut __seq: __A,
            ) -> serde::export::Result<Self::Value, __A::Error>
            where
                __A: serde::de::SeqAccess<'de>,
            {
                let __field0 = match match serde::de::SeqAccess::next_element::<String>(&mut __seq)
                {
                    serde::export::Ok(__val) => __val,
                    serde::export::Err(__err) => {
                        return serde::export::Err(__err);
                    }
                } {
                    serde::export::Some(__value) => __value,
                    serde::export::None => {
                        return serde::export::Err(serde::de::Error::invalid_length(
                            0usize,
                            &"struct TreeEntry with 11 elements",
                        ));
                    }
                };
                let __field1 =
                    match match serde::de::SeqAccess::next_element::<EntryType>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                1usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field2 =
                    match match serde::de::SeqAccess::next_element::<Option<u32>>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                2usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field3 =
                    match match serde::de::SeqAccess::next_element::<Option<u32>>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                3usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field4 =
                    match match serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                4usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field5 =
                    match match serde::de::SeqAccess::next_element::<Option<u32>>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                5usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field6 =
                    match match serde::de::SeqAccess::next_element::<Option<String>>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                6usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field7 =
                    match match serde::de::SeqAccess::next_element::<DateTime<Utc>>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                7usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field8 =
                    match match serde::de::SeqAccess::next_element::<DateTime<Utc>>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                8usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field9 =
                    match match serde::de::SeqAccess::next_element::<TreeReference>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                9usize,
                                &"struct TreeEntry with 11 elements",
                            ));
                        }
                    };
                let __field10 = match match serde::de::SeqAccess::next_element::<
                    HashMap<String, Checksum>,
                >(&mut __seq)
                {
                    serde::export::Ok(__val) => __val,
                    serde::export::Err(__err) => {
                        return serde::export::Err(__err);
                    }
                } {
                    serde::export::Some(__value) => __value,
                    serde::export::None => {
                        return serde::export::Err(serde::de::Error::invalid_length(
                            10usize,
                            &"struct TreeEntry with 11 elements",
                        ));
                    }
                };
                serde::export::Ok(TreeEntry {
                    name: __field0,
                    fstype: __field1,
                    mode: __field2,
                    uid: __field3,
                    user: __field4,
                    gid: __field5,
                    group: __field6,
                    ctime: __field7,
                    mtime: __field8,
                    reference: __field9,
                    xattrs: __field10,
                })
            }
            #[inline]
            fn visit_map<__A>(
                self,
                mut __map: __A,
            ) -> serde::export::Result<Self::Value, __A::Error>
            where
                __A: serde::de::MapAccess<'de>,
            {
                let mut __field0: serde::export::Option<String> = serde::export::None;
                let mut __field1: serde::export::Option<EntryType> = serde::export::None;
                let mut __field2: serde::export::Option<Option<u32>> = serde::export::None;
                let mut __field3: serde::export::Option<Option<u32>> = serde::export::None;
                let mut __field4: serde::export::Option<Option<String>> = serde::export::None;
                let mut __field5: serde::export::Option<Option<u32>> = serde::export::None;
                let mut __field6: serde::export::Option<Option<String>> = serde::export::None;
                let mut __field7: serde::export::Option<DateTime<Utc>> = serde::export::None;
                let mut __field8: serde::export::Option<DateTime<Utc>> = serde::export::None;
                let mut __field9: serde::export::Option<TreeReference> = serde::export::None;
                let mut __field10: serde::export::Option<HashMap<String, Checksum>> =
                    serde::export::None;
                while let serde::export::Some(__key) =
                    match serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    }
                {
                    match __key {
                        __Field::__field0 => {
                            if serde::export::Option::is_some(&__field0) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("nm"),
                                );
                            }
                            __field0 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<String>(&mut __map) {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field1 => {
                            if serde::export::Option::is_some(&__field1) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("ty"),
                                );
                            }
                            __field1 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<EntryType>(&mut __map) {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field2 => {
                            if serde::export::Option::is_some(&__field2) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("mo"),
                                );
                            }
                            __field2 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<Option<u32>>(&mut __map) {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field3 => {
                            if serde::export::Option::is_some(&__field3) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("ui"),
                                );
                            }
                            __field3 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<Option<u32>>(&mut __map) {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field4 => {
                            if serde::export::Option::is_some(&__field4) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("us"),
                                );
                            }
                            __field4 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field5 => {
                            if serde::export::Option::is_some(&__field5) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("gi"),
                                );
                            }
                            __field5 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<Option<u32>>(&mut __map) {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field6 => {
                            if serde::export::Option::is_some(&__field6) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("gr"),
                                );
                            }
                            __field6 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<Option<String>>(&mut __map)
                                {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field7 => {
                            if serde::export::Option::is_some(&__field7) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("ct"),
                                );
                            }
                            __field7 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<DateTime<Utc>>(&mut __map)
                                {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field8 => {
                            if serde::export::Option::is_some(&__field8) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("mt"),
                                );
                            }
                            __field8 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<DateTime<Utc>>(&mut __map)
                                {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field9 => {
                            if serde::export::Option::is_some(&__field9) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("tr"),
                                );
                            }
                            __field9 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<TreeReference>(&mut __map)
                                {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        __Field::__field10 => {
                            if serde::export::Option::is_some(&__field10) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("xa"),
                                );
                            }
                            __field10 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<HashMap<String, Checksum>>(
                                    &mut __map,
                                ) {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        _ => {
                            let _ = match serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(
                                &mut __map,
                            ) {
                                serde::export::Ok(__val) => __val,
                                serde::export::Err(__err) => {
                                    return serde::export::Err(__err);
                                }
                            };
                        }
                    }
                }
                let __field0 = match __field0 {
                    serde::export::Some(__field0) => __field0,
                    serde::export::None => match serde::private::de::missing_field("nm") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field1 = match __field1 {
                    serde::export::Some(__field1) => __field1,
                    serde::export::None => match serde::private::de::missing_field("ty") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field2 = match __field2 {
                    serde::export::Some(__field2) => __field2,
                    serde::export::None => match serde::private::de::missing_field("mo") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field3 = match __field3 {
                    serde::export::Some(__field3) => __field3,
                    serde::export::None => match serde::private::de::missing_field("ui") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field4 = match __field4 {
                    serde::export::Some(__field4) => __field4,
                    serde::export::None => match serde::private::de::missing_field("us") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field5 = match __field5 {
                    serde::export::Some(__field5) => __field5,
                    serde::export::None => match serde::private::de::missing_field("gi") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field6 = match __field6 {
                    serde::export::Some(__field6) => __field6,
                    serde::export::None => match serde::private::de::missing_field("gr") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field7 = match __field7 {
                    serde::export::Some(__field7) => __field7,
                    serde::export::None => match serde::private::de::missing_field("ct") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field8 = match __field8 {
                    serde::export::Some(__field8) => __field8,
                    serde::export::None => match serde::private::de::missing_field("mt") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field9 = match __field9 {
                    serde::export::Some(__field9) => __field9,
                    serde::export::None => match serde::private::de::missing_field("tr") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                let __field10 = match __field10 {
                    serde::export::Some(__field10) => __field10,
                    serde::export::None => match serde::private::de::missing_field("xa") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                serde::export::Ok(TreeEntry {
                    name: __field0,
                    fstype: __field1,
                    mode: __field2,
                    uid: __field3,
                    user: __field4,
                    gid: __field5,
                    group: __field6,
                    ctime: __field7,
                    mtime: __field8,
                    reference: __field9,
                    xattrs: __field10,
                })
            }
        }
        const FIELDS: &'static [&'static str] = &[
            "nm", "ty", "mo", "ui", "us", "gi", "gr", "ct", "mt", "tr", "xa",
        ];
        serde::Deserializer::deserialize_struct(
            __deserializer,
            "TreeEntry",
            FIELDS,
            __Visitor {
                marker: serde::export::PhantomData::<TreeEntry>,
                lifetime: serde::export::PhantomData,
            },
        )
    }
}

impl serde::Serialize for Tree {
    fn serialize<__S>(&self, __serializer: __S) -> serde::export::Result<__S::Ok, __S::Error>
    where
        __S: serde::Serializer,
    {
        let mut _serde_state =
            match serde::Serializer::serialize_struct(__serializer, "Tree", false as usize + 1) {
                serde::export::Ok(__val) => __val,
                serde::export::Err(__err) => {
                    return serde::export::Err(__err);
                }
            };
        match serde::ser::SerializeStruct::serialize_field(&mut _serde_state, "en", &self.entries) {
            serde::export::Ok(__val) => __val,
            serde::export::Err(__err) => {
                return serde::export::Err(__err);
            }
        };
        serde::ser::SerializeStruct::end(_serde_state)
    }
}

impl<'de> serde::Deserialize<'de> for Tree {
    fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
    where
        __D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        enum __Field {
            __field1,
            __ignore,
        }
        struct __FieldVisitor;
        impl<'de> serde::de::Visitor<'de> for __FieldVisitor {
            type Value = __Field;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "field identifier")
            }
            fn visit_u64<__E>(self, __value: u64) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    0u64 => serde::export::Ok(__Field::__field1),
                    _ => serde::export::Err(serde::de::Error::invalid_value(
                        serde::de::Unexpected::Unsigned(__value),
                        &"field index 0 <= i < 1",
                    )),
                }
            }
            fn visit_str<__E>(self, __value: &str) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    "en" => serde::export::Ok(__Field::__field1),
                    _ => serde::export::Ok(__Field::__ignore),
                }
            }
            fn visit_bytes<__E>(self, __value: &[u8]) -> serde::export::Result<Self::Value, __E>
            where
                __E: serde::de::Error,
            {
                match __value {
                    b"en" => serde::export::Ok(__Field::__field1),
                    _ => serde::export::Ok(__Field::__ignore),
                }
            }
        }
        impl<'de> serde::Deserialize<'de> for __Field {
            #[inline]
            fn deserialize<__D>(__deserializer: __D) -> serde::export::Result<Self, __D::Error>
            where
                __D: serde::Deserializer<'de>,
            {
                serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
            }
        }
        struct __Visitor<'de> {
            marker: serde::export::PhantomData<Tree>,
            lifetime: serde::export::PhantomData<&'de ()>,
        }
        impl<'de> serde::de::Visitor<'de> for __Visitor<'de> {
            type Value = Tree;
            fn expecting(
                &self,
                __formatter: &mut serde::export::Formatter,
            ) -> serde::export::fmt::Result {
                serde::export::Formatter::write_str(__formatter, "struct Tree")
            }
            #[inline]
            fn visit_seq<__A>(
                self,
                mut __seq: __A,
            ) -> serde::export::Result<Self::Value, __A::Error>
            where
                __A: serde::de::SeqAccess<'de>,
            {
                let __field0 = serde::export::Default::default();
                let __field1 =
                    match match serde::de::SeqAccess::next_element::<Vec<TreeEntry>>(&mut __seq) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    } {
                        serde::export::Some(__value) => __value,
                        serde::export::None => {
                            return serde::export::Err(serde::de::Error::invalid_length(
                                0usize,
                                &"struct Tree with 1 element",
                            ));
                        }
                    };
                let __field2 = serde::export::Default::default();
                serde::export::Ok(Tree {
                    digest: __field0,
                    entries: __field1,
                    file_count: __field2,
                })
            }
            #[inline]
            fn visit_map<__A>(
                self,
                mut __map: __A,
            ) -> serde::export::Result<Self::Value, __A::Error>
            where
                __A: serde::de::MapAccess<'de>,
            {
                let mut __field1: serde::export::Option<Vec<TreeEntry>> = serde::export::None;
                while let serde::export::Some(__key) =
                    match serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    }
                {
                    match __key {
                        __Field::__field1 => {
                            if serde::export::Option::is_some(&__field1) {
                                return serde::export::Err(
                                    <__A::Error as serde::de::Error>::duplicate_field("en"),
                                );
                            }
                            __field1 = serde::export::Some(
                                match serde::de::MapAccess::next_value::<Vec<TreeEntry>>(&mut __map)
                                {
                                    serde::export::Ok(__val) => __val,
                                    serde::export::Err(__err) => {
                                        return serde::export::Err(__err);
                                    }
                                },
                            );
                        }
                        _ => {
                            let _ = match serde::de::MapAccess::next_value::<serde::de::IgnoredAny>(
                                &mut __map,
                            ) {
                                serde::export::Ok(__val) => __val,
                                serde::export::Err(__err) => {
                                    return serde::export::Err(__err);
                                }
                            };
                        }
                    }
                }
                let __field1 = match __field1 {
                    serde::export::Some(__field1) => __field1,
                    serde::export::None => match serde::private::de::missing_field("en") {
                        serde::export::Ok(__val) => __val,
                        serde::export::Err(__err) => {
                            return serde::export::Err(__err);
                        }
                    },
                };
                serde::export::Ok(Tree {
                    digest: serde::export::Default::default(),
                    entries: __field1,
                    file_count: serde::export::Default::default(),
                })
            }
        }
        const FIELDS: &'static [&'static str] = &["en"];
        serde::Deserializer::deserialize_struct(
            __deserializer,
            "Tree",
            FIELDS,
            __Visitor {
                marker: serde::export::PhantomData::<Tree>,
                lifetime: serde::export::PhantomData,
            },
        )
    }
}
